<h1 id="python-generator">Python Generator</h1>

<hr />

<p>最近在写计算内存序列的backtrack algo的时候发现, 其实自己对生成器还是不是很熟练</p>

<p>生成器和Yield是Python中的一种神奇的方法, 有点类似与迭代器, 不过我觉得这个概念确实刚开始接触会有点难以理解. 一个含有yield的函数自动变成生成器.</p>

<p>生成器可以记住上一次调用在函数中的位置, 局部变量的值. 每当下一次调用迭代器的时候, 我们会使用到前一次状态中的参数.</p>

<p>我们每次调用生成器的时候, 程序会执行到 yield语句, 然后把 yield输出的值交给我们, 这时候生成器停止运行, 知道我们下一次再次调用它的时候, 他从上一次的状态中运行到 yield语句, 再一次交给我们对应的数值.</p>

<p>一个简单的斐波那契数列例子</p>

<pre><code>&lt;code&gt;def fib(n):
    a = 1, b = 1
    while a &lt; n:
        yield a 
        a,b = b, a+b
&lt;/code&gt;
</code></pre>

<p>虽然在这个例子里面, 换成print效果是差不多的=- =但是我们的目标是依赖于生成器实现更加复杂的运算.</p>

<p>比如排列组合, 无序排列</p>

<pre><code>&lt;code&gt;def perm(order):
for i in range(len(order)):
    v = order[i:i+1] 
    if len(order) == 1:
        yield v
    else:
        rest = order[ :i] + order[i+1: ]
        for p in perm(rest):
            yield v + p
&lt;/code&gt;
</code></pre>

<p>在这里我们最终的目的是要输出所有可能的排列序列, 那么在这里使用生成器就是最好的解决方案了, 主要要注意的就是在这里我们需要一个判断, 因为对于我们就是当rest=[]的时候我们是没有办法进行更深一步的运算的, 这时候不能返回任何结果.</p>

<p>对于这个程序的运算过程, 我们可以采用回推的方法, 即从len(order) == 1, rest只有一个的元素的时候往前推去理解这个函数. 因为我们每一次调用的话, 都可以看做是从yield的上一次状态进行运算, 里面也有backtrack的思想. 比如对于序列[‘a’, ‘b’, ‘c’]而言, 第一次yield 产生 abc 这个序列, 再一次调用, 从abc的状态没有办法继续向下了, 那么我返回上一步, 再从ac进行, 产生acb, 下一次调用再从acb开始, 但是不能向下了, 那我们就回溯, 这一次就回到到第一个元素, 运行到循环的第二步, 第一个元素调整为b 在开始向下运行.</p>

<p>yield和print的不同就在于它每一次都会记录上一次的状态, 这样的机制对于我们写回溯的算法有很大的帮助.</p>

<p>程序可以改写成</p>

<pre><code>&lt;code&gt;def perm(items, n = None):  
    if n is None:  
        n = len(items)  
    for i in range(len(items)):  
        v = items[i:i+1]  
        if n==1:  
            yield v  
        else:  
            rest = items[:i] + items[i+1:]  
            for p in perm(rest, n-1):  
                yield v + p 
&lt;/code&gt;
</code></pre>

<p>这样的话, 可以通过设置n来设定序列中元素的数目.</p>

<p>当然当然…懒的人也有好方法….</p>

<p>Python2.6 内置了 itertools … 可以直接用</p>

<pre><code>&lt;code&gt;print list(itertools.permutations([1,2,3,4],2))

[(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3)]
&lt;/code&gt;
</code></pre>

<p>虽然我很喜欢这样…但是还是不能偷懒…</p>
