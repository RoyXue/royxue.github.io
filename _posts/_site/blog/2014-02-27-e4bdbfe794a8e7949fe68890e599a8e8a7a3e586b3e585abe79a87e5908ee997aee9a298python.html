<p>今天重新又看了一下Python的生成器,也就是带yield的function:</p>

<p>一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。
含有yield的函数成为生成器,yield不像return那样返回值,而是一次生成多个值,每次产生一个值得时候(调用yield)函数就会被暂时冻结,然后等待被激活.</p>

<p>然后试着解决一下八皇后问题,主要还是用迭代生成器来解决.</p>

<pre><code># 8 queens    
def conflict(state,nextX):  
    nextY = len(state)  
    for i in range(nextY):  
        if abs(state[i]-nextX) in (0,nextY - i ):  
            return True  
    return False  

def queens(num=8,state=()):  
    for pos in range(num):  
        if not conflict(state,pos):  
            if len(state) == num - 1:  
                yield (pos,)  
            else:  
                for result in queens(num,state + (pos,)):  
                    yield (pos,) + result                 

#show all solution  
for solution in queens(8):  
    print solution    

#count solution   
print "The number of solutions is :"  
print len(list(queens(8)))
</code></pre>

<p>主要思路是这样的:</p>

<p>使用元组来表示皇后的位置,state[1]=2,代表皇后在第二行第三列.</p>

<p>首先要解决的就是冲突判定问题.用conflict函数来进行判定,对下一个放置的皇后的位置进行判定.利用之前放置好的皇后与要放置的皇后的水平距离来判定:1.若此水平距离为0,则两个皇后位于同一列;若此水平距离与竖直距离相等,则两个皇后位于对角线,均为冲突情况.参见:conflict</p>

<p>然后是使用了迭代的过程,同样分为两部分.一部分是前面的皇后放置好了,找下一个皇后所有可以的位置.另一部分是把之前位置的元组传递给后面的皇后.</p>
